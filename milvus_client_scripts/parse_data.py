import json

# Function to convert column-based data to row-based data
def parse_column_based_data(column_data):
    """
    Convert column-based JSON data to row-based format.
    
    Args:
        column_data: Dictionary containing fieldsData with column-based structure
    
    Returns:
        List of dictionaries, each representing a row
    """
    fields_data = column_data.get("fieldsData", [])
    if not fields_data:
        return []
    
    # Get the number of rows from any field (they should all have the same numRows)
    num_rows = int(column_data.get("numRows", 0))
    if num_rows == 0:
        return []
    
    # Initialize list of row dictionaries
    rows = [{} for _ in range(num_rows)]
    
    # Process each field
    for field in fields_data:
        field_name = field.get("fieldName", "")
        field_type = field.get("type", "")
        field_id = field.get("fieldId", "")
        
        if field_type == "VarChar":
            # Handle VARCHAR fields
            string_data = field.get("scalars", {}).get("stringData", {}).get("data", [])
            for i, value in enumerate(string_data):
                if i < num_rows:
                    rows[i][field_name] = value
                    
        elif field_type == "Int64":
            # Handle INT64 fields
            long_data = field.get("scalars", {}).get("longData", {}).get("data", [])
            for i, value in enumerate(long_data):
                if i < num_rows:
                    rows[i][field_name] = int(value)
                    
        elif field_type == "FloatVector":
            # Handle FloatVector fields
            vector_data = field.get("vectors", {}).get("floatVector", {}).get("data", [])
            dim = int(field.get("vectors", {}).get("dim", 4096))
            
            # Split flat vector data into individual vectors
            for i in range(num_rows):
                start_idx = i * dim
                end_idx = start_idx + dim
                if end_idx <= len(vector_data):
                    rows[i][field_name] = vector_data[start_idx:end_idx]
                else:
                    rows[i][field_name] = [0.0] * dim  # Default vector
                    
        elif field_type == "Array":
            # Handle Array fields
            array_data = field.get("scalars", {}).get("arrayData", {}).get("data", [])
            for i, array_item in enumerate(array_data):
                if i < num_rows:
                    # Extract string data from array
                    string_data = array_item.get("stringData", {}).get("data", [])
                    rows[i][field_name] = string_data
                    
        elif field_type == "SparseFloatVector":
            # Handle SparseFloatVector fields - will be generated by BM25 function
            # Initialize as empty, will be populated by Milvus BM25 function
            for i in range(num_rows):
                rows[i][field_name] = {}
    
    return rows

# Load and prepare data for insertion
def load_data(file_path):
    data = []
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line:  # Skip empty lines
                try:
                    column_data = json.loads(line)
                    # Convert column-based data to row-based
                    row_data = parse_column_based_data(column_data)
                    data.extend(row_data)
                except json.JSONDecodeError as e:
                    print(f"Error parsing JSON line: {e}")
                    continue
    
    print(f"Loaded {len(data)} records from {file_path}")
    return data
